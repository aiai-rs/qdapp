<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#0f1621">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>æ±‡ç›ˆå›½é™…å®˜æ–¹å®¢æœ</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: { tg: { bg: "#0f1621", header: "#17212b", input: "#0e1621", blue: "#2b5278", secondary: "#182533", accent: "#0088cc" } },
                    animation: { 'slide-up': 'slideUp 0.3s ease-out' },
                    keyframes: { slideUp: { '0%': { transform: 'translateY(10px)', opacity: '0' }, '100%': { transform: 'translateY(0)', opacity: '1' } } }
                }
            }
        }
    </script>
    <style>
        /* iOS å®‰å…¨åŒºåŸŸé€‚é… */
        :root {
            --sat: env(safe-area-inset-top);
            --sab: env(safe-area-inset-bottom);
        }
        body { background-color: #0f1621; overflow: hidden; overscroll-behavior: none; }
        /* è¿™é‡Œçš„ height: 100dvh æ˜¯ä¸ºäº†è§£å†³ iOS Safari åœ°å€æ å˜åŒ–å¯¼è‡´çš„é«˜åº¦è·³åŠ¨ */
        #root { height: 100dvh; display: flex; flex-direction: column; }
        
        /* é€‚é…ç±» */
        .pt-safe { padding-top: var(--sat); }
        .pb-safe { padding-bottom: var(--sab); }
        
        .ios-scroll { -webkit-overflow-scrolling: touch; }
        
        /* å›¾ç‰‡é¢„è§ˆæ¨¡æ€æ¡†åŠ¨ç”» */
        .preview-enter { opacity: 0; transform: scale(0.95); }
        .preview-enter-active { opacity: 1; transform: scale(1); transition: all 0.2s; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const SOCKET_URL = "https://lt-1li6.onrender.com"; // ä½ çš„åç«¯åœ°å€

        function App() {
            // çŠ¶æ€ç®¡ç†
            const [step, setStep] = useState('loading'); // loading, login, chat
            const [userId, setUserId] = useState('');
            const [bossId, setBossId] = useState('');
            const [inputVal, setInputVal] = useState(''); // ç™»å½•è¾“å…¥
            const [chatInput, setChatInput] = useState(''); // èŠå¤©è¾“å…¥
            const [messages, setMessages] = useState([]);
            const [previewImg, setPreviewImg] = useState(null); // å›¾ç‰‡å¤§å›¾é¢„è§ˆ
            const [errorMsg, setErrorMsg] = useState('');
            
            const socketRef = useRef(null);
            const messagesEndRef = useRef(null);

            // åˆå§‹åŒ–æ£€æŸ¥æœ¬åœ°ç¼“å­˜
            useEffect(() => {
                const cachedUid = localStorage.getItem('hy_uid');
                const cachedBoss = localStorage.getItem('hy_boss');
                if (cachedUid && cachedBoss) {
                    doLogin(cachedUid, cachedBoss);
                } else {
                    setStep('login');
                }
            }, []);

            // æ»šåŠ¨åˆ°åº•éƒ¨
            const scrollToBottom = () => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            };
            useEffect(scrollToBottom, [messages]);

            // === æ ¸å¿ƒé€»è¾‘ï¼šç™»å½•/æ‰¾å› ===
            const handleLogin = async () => {
                const val = inputVal.trim();
                if (!val) return;
                
                // åˆ¤æ–­æ˜¯æ‰¾å›IDï¼ˆçº¯æ•°å­—ï¼‰è¿˜æ˜¯æ–°æ³¨å†Œï¼ˆ@å¼€å¤´æˆ–å­—æ¯ï¼‰
                const isRecovery = /^\d+$/.test(val); // å‡è®¾IDæ˜¯çº¯æ•°å­—ï¼Œæˆ–è€…ä½ æ ¹æ®é•¿åº¦åˆ¤æ–­

                if (isRecovery) {
                    // [æ–°å¢] æ‰¾å›æ¨¡å¼ï¼šå¿…é¡»å»åç«¯éªŒè¯ ID æ˜¯å¦å­˜åœ¨
                    try {
                        const res = await fetch(`${SOCKET_URL}/api/check-user`, {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({ userId: val })
                        });
                        const data = await res.json();
                        
                        if (data.exists) {
                            localStorage.setItem('hy_uid', val);
                            doLogin(val, 'æœªçŸ¥(æ¢å¤)');
                        } else {
                            setErrorMsg("âŒ é”™è¯¯ï¼šè¯¥ ID ä¸å­˜åœ¨æˆ–å·²è¢«åˆ é™¤");
                        }
                    } catch (e) {
                        setErrorMsg("ç½‘ç»œè¿æ¥å¤±è´¥");
                    }
                } else {
                    // æ–°æ³¨å†Œæ¨¡å¼ (è¾“å…¥è€æ¿ID)
                    const bossName = val.replace('@', '').toLowerCase();
                    const validBosses = ['rrii8', 'iibb8']; // å…è®¸çš„è€æ¿åˆ—è¡¨
                    
                    if (validBosses.includes(bossName)) {
                        const tempSocket = io(SOCKET_URL);
                        tempSocket.emit('request_id', (newId) => {
                            tempSocket.disconnect();
                            localStorage.setItem('hy_uid', newId);
                            localStorage.setItem('hy_boss', '@' + bossName);
                            doLogin(newId, '@' + bossName);
                        });
                    } else {
                        setErrorMsg("âŒ æœªæ‰¾åˆ°è¯¥è€æ¿ï¼Œè¯·æ£€æŸ¥ç”¨æˆ·å");
                    }
                }
            };

            // === æ ¸å¿ƒé€»è¾‘ï¼šå»ºç«‹è¿æ¥ ===
            const doLogin = (uid, bid) => {
                setUserId(uid);
                setBossId(bid);
                setStep('chat');

                // è¿æ¥ Socket
                socketRef.current = io(SOCKET_URL, {
                    query: { userId: uid, bossId: bid }
                });

                socketRef.current.on('connect', () => {
                    console.log("å·²è¿æ¥");
                });

                // [æ–°å¢] ç›‘å¬å¼ºåˆ¶ä¸‹çº¿ï¼ˆè¢«åˆ å·æˆ–æ¸…ç©ºï¼‰
                socketRef.current.on('force_disconnect', () => {
                    localStorage.clear();
                    alert("ğŸš« æ‚¨çš„ä¼šè¯å·²ç»“æŸï¼ˆè®°å½•è¢«æ¸…é™¤æˆ–è´¦å·è¢«å°ç¦ï¼‰");
                    window.location.reload();
                });

                // æ¥æ”¶æ¶ˆæ¯
                socketRef.current.on('receive_message', (msg) => {
                    setMessages(prev => {
                        // å¦‚æœæ˜¯è‡ªå·±å‘çš„å›¾ç‰‡ï¼ˆå·²ç»æœ¬åœ°é¢„è§ˆäº†ï¼‰ï¼Œæ›¿æ¢æ‰é‚£ä¸ª temp æ¶ˆæ¯
                        if (msg.tempId) {
                            return prev.map(m => m.tempId === msg.tempId ? msg : m);
                        }
                        return [...prev, msg];
                    });
                });

                // åŠ è½½å†å²è®°å½•
                fetch(`${SOCKET_URL}/api/history/${uid}`)
                    .then(r => r.json())
                    .then(data => setMessages(data));
            };

            // === æ ¸å¿ƒé€»è¾‘ï¼šå‘é€æ¶ˆæ¯ ===
            const sendMessage = (type, content, tempId = null) => {
                const msgData = {
                    userId,
                    bossId,
                    content,
                    type,
                    tempId: tempId || Date.now(), // ç”¨äºä¹è§‚æ›´æ–°
                    isFromUser: true,
                    createdAt: new Date()
                };
                socketRef.current.emit('send_message', msgData);
            };

            const handleSendText = () => {
                if (!chatInput.trim()) return;
                // ä¹è§‚æ›´æ–°ï¼šå…ˆæ˜¾ç¤ºåœ¨ç•Œé¢ä¸Š
                const tempMsg = {
                    userId, content: chatInput, type: 'text', isFromUser: true, createdAt: new Date(), status: 'sending'
                };
                setMessages(prev => [...prev, tempMsg]);
                sendMessage('text', chatInput);
                setChatInput('');
            };

            // === [æ–°å¢] å›¾ç‰‡å‹ç¼©ä¸ç§’æ˜¾é€»è¾‘ ===
            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                // 1. æœ¬åœ°é¢„è§ˆ (ç§’æ˜¾)
                const localUrl = URL.createObjectURL(file);
                const tempId = Date.now();
                
                // ç«‹å³æ·»åŠ åˆ°æ¶ˆæ¯åˆ—è¡¨ï¼Œä¸ç”¨ç­‰æœåŠ¡å™¨
                const tempMsg = {
                    userId, 
                    content: localUrl, 
                    type: 'image', 
                    isFromUser: true, 
                    createdAt: new Date(), 
                    tempId: tempId, // æ ‡è®°ä¸ºä¸´æ—¶æ¶ˆæ¯
                    status: 'uploading' // å¯ä»¥ç”¨æ¥æ˜¾ç¤ºè½¬åœˆåœˆ
                };
                setMessages(prev => [...prev, tempMsg]);

                // 2. å‹ç¼©å›¾ç‰‡ (è§£å†³å‘é€æ…¢çš„é—®é¢˜)
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        // é™åˆ¶æœ€å¤§å®½åº¦ 800pxï¼Œå¤§å¹…å‡å°ä½“ç§¯
                        const scale = 800 / img.width;
                        const w = img.width > 800 ? 800 : img.width;
                        const h = img.width > 800 ? img.height * scale : img.height;
                        
                        canvas.width = w;
                        canvas.height = h;
                        ctx.drawImage(img, 0, 0, w, h);
                        
                        // å‹ç¼©ä¸º 0.7 è´¨é‡çš„ JPEG
                        const base64 = canvas.toDataURL('image/jpeg', 0.7);
                        
                        // 3. å‘é€ç»™æœåŠ¡å™¨
                        sendMessage('image', base64, tempId);
                    };
                };
            };

            // === ç•Œé¢æ¸²æŸ“ ===
            if (step === 'loading') return <div className="h-full bg-tg-bg flex items-center justify-center text-white">åŠ è½½ä¸­...</div>;

            if (step === 'login') return (
                <div className="h-full bg-tg-bg flex flex-col items-center justify-center px-6">
                    <div className="w-20 h-20 bg-blue-600 rounded-full flex items-center justify-center text-3xl font-bold text-white mb-6 shadow-lg">HY</div>
                    <h2 className="text-white text-2xl font-bold mb-2">æ±‡ç›ˆå›½é™…å®¢æœ</h2>
                    <p className="text-gray-400 text-sm mb-8 text-center">è¯·è¾“å…¥ <span className="text-blue-400">è€æ¿TGå·</span> æˆ– <span className="text-green-400">æ—§è´¦å·ID</span></p>
                    
                    <input 
                        type="text" 
                        value={inputVal}
                        onChange={e => setInputVal(e.target.value)}
                        className="w-full bg-tg-input text-white border border-gray-700 rounded-xl p-4 mb-4 focus:border-blue-500 outline-none transition"
                        placeholder="ä¾‹å¦‚: @boss888 æˆ– 123456"
                    />
                    {errorMsg && <p className="text-red-500 text-sm mb-4">{errorMsg}</p>}
                    
                    <button onClick={handleLogin} className="w-full bg-blue-600 active:bg-blue-700 text-white font-bold py-4 rounded-xl transition shadow-lg">
                        å¼€å§‹å’¨è¯¢
                    </button>
                </div>
            );

            return (
                <div className="h-full bg-tg-bg flex flex-col relative">
                    {/* Header: å¢åŠ  pt-safe é€‚é…åˆ˜æµ· */}
                    <header className="bg-tg-header pt-safe px-4 py-3 flex justify-between items-center border-b border-gray-800 shrink-0 z-10">
                        <div className="flex items-center gap-3">
                            <div className="w-9 h-9 bg-blue-600 rounded-full flex items-center justify-center text-white font-bold text-sm">HY</div>
                            <div>
                                <div className="text-white font-bold text-sm">æ±‡ç›ˆå›½é™…å®¢æœ</div>
                                <div className="text-green-400 text-xs">â— åœ¨çº¿ ID: {userId}</div>
                            </div>
                        </div>
                    </header>

                    {/* Chat Area: å¢åŠ  pb-32 ç»™åº•éƒ¨ç•™ç©ºé—´ */}
                    <div className="flex-1 overflow-y-auto ios-scroll p-4 pb-4 space-y-4">
                        {messages.map((msg, idx) => (
                            <div key={idx} className={`flex ${msg.isFromUser ? 'justify-end' : 'justify-start'} animate-slide-up`}>
                                {!msg.isFromUser && <div className="w-8 h-8 bg-blue-600 rounded-full flex-shrink-0 mr-2 flex items-center justify-center text-xs text-white">HY</div>}
                                <div className={`max-w-[75%] p-3 rounded-2xl text-sm break-words ${msg.isFromUser ? 'bg-blue-600 text-white rounded-tr-sm' : 'bg-tg-secondary text-white rounded-tl-sm'}`}>
                                    {msg.type === 'image' ? (
                                        <div className="relative">
                                            <img 
                                                src={msg.content} 
                                                className={`rounded-lg max-h-48 object-cover cursor-pointer ${msg.status === 'uploading' ? 'opacity-70' : ''}`} 
                                                onClick={() => setPreviewImg(msg.content)}
                                            />
                                            {msg.status === 'uploading' && <div className="absolute inset-0 flex items-center justify-center"><div className="w-5 h-5 border-2 border-white border-t-transparent rounded-full animate-spin"></div></div>}
                                        </div>
                                    ) : (
                                        msg.content
                                    )}
                                    <div className="text-[10px] text-right mt-1 opacity-70">
                                        {new Date(msg.createdAt).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                                    </div>
                                </div>
                            </div>
                        ))}
                        <div ref={messagesEndRef} />
                    </div>

                    {/* Footer: å¢åŠ  pb-safe é€‚é…åº•éƒ¨é»‘æ¡ */}
                    <div className="bg-tg-header border-t border-gray-800 p-3 pb-safe shrink-0 flex items-center gap-2 z-10">
                        <label className="p-2 text-gray-400 active:text-blue-500 cursor-pointer">
                            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg>
                            <input type="file" accept="image/*" className="hidden" onChange={handleImageUpload} />
                        </label>
                        <input 
                            type="text" 
                            value={chatInput}
                            onChange={e => setChatInput(e.target.value)}
                            onKeyDown={e => e.key === 'Enter' && handleSendText()}
                            placeholder="è¾“å…¥æ¶ˆæ¯..." 
                            className="flex-1 bg-tg-input text-white text-sm rounded-full py-2 px-4 border border-gray-700 focus:border-blue-500 outline-none"
                        />
                        <button onClick={handleSendText} className="p-2 text-blue-500 font-bold active:opacity-70">å‘é€</button>
                    </div>

                    {/* [æ–°å¢] å®Œç¾é€‚é…çš„å…¨å±å›¾ç‰‡é¢„è§ˆ */}
                    {previewImg && (
                        <div 
                            className="fixed inset-0 z-50 bg-black bg-opacity-95 flex items-center justify-center backdrop-blur-sm"
                            onClick={() => setPreviewImg(null)}
                        >
                            <div className="absolute top-safe right-4 p-4 text-white z-50 cursor-pointer text-3xl">Ã—</div>
                            <img src={previewImg} className="max-w-full max-h-full object-contain p-2" />
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
